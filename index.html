<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lexend+Deca:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <title>Cool Reaction Game</title>
</head>
<body>
    <div class="bg"></div>

    <div class="dashboard">
        <h3>Preview</h3>
        <div id="selected-style">
            <span>
                <h4>Current style:</h4>
                <span>
                    <h4 style="color: var(--c-primary);">colored</h4>
                    <h4 style="color: #fff;">selected</h4>
                    <h4 style="color: var(--c-complimentary);">target</h4>
                </span>
            </span>
            <img id="dash-current-style" src="assets/colored/cube.png" alt="selected style">
        </div>
        <!-- <h3>Theme</h3>
        <div class="theme-selection"></div> -->
        <h3>Soundtrack</h3>
        <div class="music">
            <h5>playing now</h5>
            <div class="playing-now">
                <span>
                    <img id="pn-cover" src="">
                    <h5 id="current-title">--:--</h5>
                </span>
                <span>
                    <div>
                        <input id="song-slider" type="range" value="0" min="0" step="0.1">
                        <div id="listened"></div>
                    </div>
                    <span id="controls-container">
                        <h5 id="current-time">--:--</h5>
                        <span id="controls">
                            <!-- <img src="assets/unk/prev.png" onclick="prevBtn()"> -->
                            <img src="assets/unk/play.png" onclick="playBtn()">
                            <!-- <img src="assets/unk/next.png" onclick="nextBtn()"> -->
                        </span>
                        <h5 id="left-time">--:--</h5>
                    </span>
                </span>
            </div>
            <h5>tracks</h5>
            <div class="track-list">
                <h5>library</h5>
            </div>
            <h5>add your music</h5>
            <span id="drop-zone">
                <h5>Click to choose file</h5>
                <h6>or drop it here</h6>
                <input type="file" id="trackinput" name="trackinput" accept="audio/*">
            </span>
        </div>
    </div>

    <!-- Rules of the Game
    Quick summary
    You pick a unit (an object image) from the left selector, choose one visible unit on the canvas as your unit, then press start. During the run the game repeatedly highlights a random unit (the “target”). When you tap the canvas to stop, if the last highlighted unit equals the unit you originally chose → Win. If it’s different or time runs out → Loss. -->

    <div class="game-setup">
        <div>
            <label>
                <span id="nunitsvis">units: 10</span>
                <input type="range" name="nofunits" id="nofunits" min="5" max="30" value="10">
            </label>
        </div>
        <h3>pick style</h3>
        <div class="unit-style"></div>
    </div>

    <div class="container">
        <canvas id="game-space"></canvas>
    </div>
    <span id="timer"></span>
    <button id="start-btn"><span id="bottom-btn">set</span></button>

    <div class="end-container">
        <h1 id="verdict"></h1>
        <button id="retry-btn"><span>play again</span></button>
    </div>

    <div class="rules">
        <p>Rules of the Game
            Quick summary
            You pick a unit (an object image) from the left selector, choose one visible unit on the canvas as your unit, then press start. During the run the game repeatedly highlights a random unit (the “target”). When you tap the canvas to stop, if the last highlighted unit equals the unit you originally chose → Win. If it’s different or time runs out → Loss.</p>
    </div>

    <!-- Soundtracks/Input -->
    <script>
        const d = document;

        const trackList = d.querySelector('.track-list');
        const soundLibrary = [
            'Sunrise',
            'Subwoofer Lullaby',
            'Droopy likes ricochet',
            'Haggstrom',
            'Excuse',
            'Living Mice',
            'Moog City',
            'Dog',
            'Cat'
        ]

        function toTimeFormat(time) {
            const minutes = Math.floor(time / 60);
            const secs = Math.floor(time % 60);
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        const notification = d.createElement('div');
        const playingCover = d.createElement('img');
        const playingTitle = d.createElement('h5');

        notification.className = 'playing-notification';

        notification.append(playingCover,playingTitle);
        d.body.insertAdjacentElement('afterbegin', notification);

        const soundtracks = [];
        let currentTrack = null;

        const pnCover = d.getElementById('pn-cover');
        const pnTitle = d.getElementById('current-title');
        const pnCTime = d.getElementById('current-time');
        const pnLTime = d.getElementById('left-time');
        const pnPlayBtn = d.querySelector('#controls img');
        const songSlider = d.getElementById('song-slider');

        for (let trackName of soundLibrary) {
            const trackLine = d.createElement('span');
            const trackCover = d.createElement('img');
            const trackTitle = d.createElement('h5');
            const trackDuration = d.createElement('h5');

            const imageNum = Math.floor(Math.random() * 5);

            trackLine.className = 'track-line';
            trackCover.src = `assets/sound/covers/cover${imageNum}.png`;
            
            trackTitle.textContent = trackName;
            trackDuration.style.marginRight = '3vh';
            trackDuration.style.textAlign = 'right';
            
            const track = new Audio(`assets/sound/tracks/${trackName}.mp3`);
            track.addEventListener("loadedmetadata", () => {
                trackDuration.textContent = toTimeFormat(track.duration);
            });
            function restartAnimation(el, animation) {
                el.style.animation = 'none';
                void el.offsetWidth;
                el.style.animation = animation;
            }
            soundtracks.push(track.src);

            trackLine.addEventListener('click', () => {
                const coverImage = new Image();
                coverImage.src = trackCover.src;

                // new song
                if (currentTrack && currentTrack !== track) {
                    currentTrack.pause();
                    currentTrack.currentTime = 0;
                }
                // if same —– pause, else —— play
                if (currentTrack === track && !track.paused) {
                    track.pause();

                    pnPlayBtn.src = 'assets/unk/play.png';
                    
                    playingTitle.innerHTML = `<mark>${trackTitle.textContent}</mark> is paused`;
                    restartAnimation(notification, 'notification linear 4s');
                } else {
                    track.play();
                    currentTrack = track;
                    
                    pnPlayBtn.src = 'assets/unk/pause.png';

                    coverImage.onload = () => {
                        playingCover.src = trackCover.src;
                        playingTitle.innerHTML = `<mark>${trackTitle.textContent}</mark> is playing`;
                    };
                    coverImage.src = trackCover.src;
                    notification.style.setProperty("--n-bg-cover",`url(${coverImage.src})`);
                    restartAnimation(notification, 'notification linear 4s');

                    pnCover.src = trackCover.src;
                    pnTitle.textContent = trackTitle.textContent;
                    pnLTime.textContent = `-${trackDuration.textContent}`;
                    
                    track.addEventListener('timeupdate', () => {
                        pnCTime.textContent = toTimeFormat(track.currentTime);
                        const remaining = track.duration - track.currentTime;
                        pnLTime.textContent = `-${toTimeFormat(remaining)}`;

                        if (!isNaN(track.duration)) {
                            const listened = (track.currentTime / track.duration) * 120;
                            songSlider.style.setProperty('--listened',`${listened}%`);
                        }

                        if (track.currentTime == track.duration) {
                            pnPlayBtn.src = 'assets/unk/play.png';
                        }
                    });
                    songSlider.addEventListener('input', () => {
                        if (!currentTrack || isNaN(currentTrack.duration)) return;
                        currentTrack.currentTime = currentTrack.duration * ((songSlider.value) / 100);
                    });
                }
            });
            
            trackLine.append(trackCover,trackTitle,trackDuration);
            trackList.appendChild(trackLine);
        }

        trackList.addEventListener('scroll', () => {
            if (trackList.scrollTop >= 10) {
                trackList.style.maskImage = 'linear-gradient(to top, transparent, black 20% 80%, transparent)';
            } else {
                trackList.style.maskImage = 'linear-gradient(to top, transparent, black 20%)';
            }
        });

        function playBtn() {
            if (currentTrack) {
                if (!currentTrack.paused) {
                    currentTrack.pause();
                    pnPlayBtn.src = 'assets/unk/play.png';
                } else {
                    currentTrack.play();
                    pnPlayBtn.src = 'assets/unk/pause.png';
                }
            } else {
                alert('Choose a soundtrack')
            }
        }
        function playNext() {
            for (let i = 0; i < soundtracks.length; i++) {
                if (currentTrack && currentTrack !== track) {
                //     currentTrack.pause();
                //     currentTrack.currentTime = 0;
                }
                if (currentTrack === track && !track.paused) {
                    // track.pause();

                    // notification.style.setProperty('--n-bg-cover',`url(${trackCover.src})`);
                    // playingCover.src = trackCover.src;
                    // playingTitle.innerHTML = `<mark>${trackTitle.textContent}</mark> is paused.`;
                    // restartAnimation(notification, 'notification linear 4s');
                } else {
                    // track.play();
                    // currentTrack = track;
                    
                    // notification.style.setProperty('--n-bg-cover',`url(${trackCover.src})`);
                    // playingCover.src = trackCover.src;
                    // playingTitle.innerHTML = `<mark>${trackTitle.textContent}</mark> is playing.`;
                    // restartAnimation(notification, 'notification linear 4s');
                }
            }
        };

        trackinput.addEventListener('change', () => {

            if (trackinput.files.length > 0) {
                // trackList.appendChild()
            }
            
            // const dzH5 = d.querySelector('#drop-zone h5');
            // const dzH6 = d.querySelector('#drop-zone h6');
            // // const dzH6 = d.querySelector('#drop-zone h6');

            // if (trackinput.files.length > 0) {
            //     dzH6.remove();
            //     dzH5.textContent = `${trackinput.files[0].name}`;
            // } else {
            //     const dzH6_new = d.createElement('h6');

            //     dzH6_new.textContent = 'or drop it here';
            //     dzH5.textContent = 'Click to choose file';

            //     dzH5.insertAdjacentElement('afterend',dzH6_new);
            // }
        });
    </script>
    <!-- Desktop extension -->
    <script>
        const bg = document.querySelector('.bg')
        const usltaIMGs = document.getElementById('uslta');
        const bgMultiplier = 1.2;
        if (window.innerWidth > window.innerHeight) {
            document.documentElement.style.setProperty('--box-primary-width','30%');
            bg.style.display = 'none';
            bg.style.marginLeft = `${(window.innerWidth - bg.offsetWidth) / 2}px`;
            bg.style.boxShadow = 'inset 0 -1vh 3vh var(--c-primary), inset 0 -.6vh .5vh var(--c-secondary), 0 0 3vh var(--c-primary), 0 0 .5vh var(--c-secondary)';
            
            const themePrimaryColor = getComputedStyle(document.documentElement).getPropertyValue('--c-primary');
            var TPCrgb = themePrimaryColor.match(/\d+/g).join(",");
            document.documentElement.style.setProperty('--tpc-rgb',`${TPCrgb}`);
            document.body.style.background = `radial-gradient(circle at -40% 50%, rgb(${TPCrgb},.4), transparent 45%), radial-gradient(circle at 140% 50%, rgb(${TPCrgb},.4), transparent 45%)`;

            document.querySelector('.container').style.height = '65%';
            document.querySelector('.container').style.transform = 'translateY(15%)';
            document.getElementById('retry-btn').style.width = 'calc(var(--box-primary-width) * .6)';
        }
    </script>
    <!-- Main -->
    <script>
        const GameSetupDiv = document.querySelector('.game-setup');
        GameSetupDiv.style.marginTop = `${(window.innerHeight - GameSetupDiv.offsetHeight) / 2}px`;

        const c = 'colored';
        const p = 'plain';
        const s = 'selected';
        const u = 'unk'

        let object = 'cube';
        let maxAngle = Math.PI / 3.5;
        var imageScale = 1.3

        const objects = [
            'cube',
            'crown',
            'disco-ball',
            'robot',
            'rubber-duck',
            'frog-px',
            'croc',
            'freaked-croc',
            'monkey',
            'dinosaur',
            'monster',
            'penguin',
            'car'
        ];
        const unitStylingArea = d.querySelector('.unit-style');

        for (let i = 0; i < objects.length; i++) {
            const el = d.createElement('div')
            const imgDiv = d.createElement('div')
            const dashCurStyle = d.getElementById('dash-current-style');
            
            if (object == objects[i]) el.style.setProperty('--theme','#fff')
            
            function selection() {
                object = objects[i];
                unitStylingArea.children[i].style.setProperty('--theme','#fff')
                d.querySelector('.container').style.setProperty('--canva-bg',`url(assets/${c}/${object}.png)`)
                dashCurStyle.src = `assets/${c}/${object}.png`;

                console.warn('Style switched.')
                console.log(`New style: ${object}`)
                for (let idx = 0; idx < unitStylingArea.children.length; idx++) {
                    if (idx !== i) {
                        unitStylingArea.children[idx].style.setProperty('--theme','var(--c-complimentary)')
                    }
                }
            }

            if (objects[i].includes('frog')) {
                el.className = 'tracked';
            }
            el.id = 'uslta';

            el.addEventListener('click', selection);
            imgDiv.style.setProperty('--image',`url(assets/${c}/${objects[i]}.png)`);

            el.appendChild(imgDiv);
            unitStylingArea.appendChild(el);

        }
        const spacer = d.createElement('div');
        spacer.className = 'spacer';
        unitStylingArea.appendChild(spacer);
        
        const trackedEl = d.querySelector('.tracked');

        const screenCenter = window.innerWidth / 2;
        const minScale = 0.6;
        const falloff = 200;

        for (let obj of d.querySelectorAll('#uslta')) {
            const rect = obj.getBoundingClientRect();
            const objCenter = rect.left + rect.width / 2;
            const distance = Math.abs(screenCenter - objCenter);
            let scale = 1 - (distance / falloff);
            
            scale = Math.max(minScale, Math.min(1, scale));
            obj.style.transform = `scale(${scale})`;
        }
        unitStylingArea.addEventListener('scroll', function () {
            const screenCenter = window.innerWidth / 2;
            const falloff = 200;

            for (let obj of d.querySelectorAll('#uslta')) {
                const rect = obj.getBoundingClientRect();
                const objCenter = rect.left + rect.width / 2;
                const distance = Math.abs(screenCenter - objCenter);
                let scale = 1 - (distance / falloff);
                
                scale = Math.max(.2, Math.min(1, scale));
                obj.style.transform = `scale(${scale})`;
            }
        });

        // Dashboard
        const scrollBox = document.querySelector('#selected-style span span');
        const styleOptions = document.querySelectorAll('#selected-style span span h4');
        const dashImage = document.getElementById('dash-current-style');

        
        function updateCurrentStyle() {
            const styleImages = {
                colored: `assets/${c}/${object}.png`,
                selected: `assets/${p}/${object}.png`,
                target: `assets/${s}/${object}.png`
            };

            const boxRect = scrollBox.getBoundingClientRect();
            const boxCenter = boxRect.top + boxRect.height / 2;

            let closest = null;
            let closestDist = Infinity;

            styleOptions.forEach(h4 => {
                const rect = h4.getBoundingClientRect();
                const h4Center = rect.top + rect.height / 2;
                const dist = Math.abs(h4Center - boxCenter);
                if (dist < closestDist) {
                closestDist = dist;
                closest = h4;
                }
            });

            if (closest) {
                const styleName = closest.textContent.trim().toLowerCase();
                if (styleImages[styleName]) {
                dashImage.src = styleImages[styleName];
                }
            }
        };

        let scrollTimeout;
        scrollBox.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(updateCurrentStyle, 120); // adjust delay if needed
        });
        updateCurrentStyle();

        // styleOptions.forEach(h4 => observer.observe(h4));

        const timer = d.getElementById('timer')
        const setUpSection = d.querySelector('.game-setup');
        const startBtn = d.getElementById('start-btn');
        const startBtnSpan = d.getElementById('bottom-btn');
        const canvas = d.querySelector('#game-space');
        const ctx = canvas.getContext('2d',{ alpha: true });
        
        const gameSpeed = 273; // median human reaction time
        
        const primaryColor = '#fff';
        const secondaryColor = 'rgb(255,0,89)';
        const tertiaryColor = 'rgb(0,255,166)';
        const maxMinTime = 8;
        let initialSetUp = true
        let win;
        var unitnum = 0
        var time = 0

        timer.textContent = `10.00s`

        nofunits.addEventListener('input', () => {
            const nunitsVis = d.getElementById('nunitsvis');
            nunitsVis.textContent = `units: ${nofunits.value}`;
            const timeLimit = nofunits.value**2 /10
            time = Math.max(maxMinTime,timeLimit)
            timer.textContent = `${time.toFixed(2)}s`
        })
        
        startBtn.addEventListener('click', begin)

        function begin() {
            if (initialSetUp) {
                const setupBtn = `<button onclick="location.reload(); nofunits.value = 10" id="game-setup-btn"><img src="assets/${u}/setting.png" alt="N Balls"></button>`
                const chosen = `<div id="chosen"><img src="assets/${p}/${object}.png"><p>selected<br>(you choose)</p></div>`;
                const target = `<div id="target"><img src="assets/${s}/${object}.png"><p>target<br>(look for it)</p></div>`;
                
                timer.insertAdjacentHTML('beforebegin', setupBtn)
                timer.insertAdjacentHTML('afterend', chosen)
                timer.insertAdjacentHTML('afterend', target)
                initialSetUp = false
            }
            d.querySelector('.container').style.setProperty('--canvas-bg-display','block')
            d.querySelector('.container').style.setProperty('--canvas-bg-anim','canvasBGSpin 5s linear infinite')
            startBtn.onclick = null;
            startBtnSpan.textContent = 'start';
            setUpSection.style.display = 'none';
            unitnum = nofunits.value
            GAME();
        }

        class Ball {
            constructor(x,y,r,source) {
                this.x = x
                this.y = y
                this.r = r
                this.source = source
                this.unitImage = new Image();
                this.unitImage.src;
                this.angle = (Math.random() * 2 - 1) * (maxAngle)
            }
            draw(ctx) {
                const size = this.r * imageScale * 2
                ctx.save();
                ctx.translate(this.x, this.y)
                ctx.rotate(this.angle);
                ctx.drawImage(
                    this.unitImage, 
                    -size / 2,
                    -size / 2,
                    size,
                    size
                )
                ctx.restore();
            }
        }

        function GAME() {
            const defaultSource = `assets/${c}/${object}.png`;
            const chosenBallSource = `assets/${p}/${object}.png`;
            const randBallSource = `assets/${s}/${object}.png`;

            startBtn.removeEventListener('click', begin);

            const timeLimit = nofunits.value**2 /20
            time = Math.max(maxMinTime,timeLimit)
    
            var units = []
            const r = 14.6
            const ofsVal = 3
            const ofs = ofsVal*r
    
            function ValidatePos(x,y) {
                for (const unit of units) {
                    const distance = Math.sqrt((x - unit.x)**2 + (y - unit.y)**2)
                    if (distance < r * 2 * imageScale * 1.3 ) return false;
                }
                return true;
            }
            function spawnBalls() {
                units = []
                for (let i = 0; i < unitnum; i++) {
                    IsValid = false
                    while (!IsValid) {
                        xPos = Math.floor(Math.random() * (canvas.clientWidth - ofs*2)) + ofs
                        yPos = Math.floor(Math.random() * (canvas.clientHeight - ofs*2)) + ofs
                        IsValid = ValidatePos(xPos,yPos);
                    }
                    let source = defaultSource;
                    let unit = new Ball(xPos,yPos,r,source)
                    units.push(unit)
                }
                drawBalls();
                console.log('Unit source:');
                units.forEach(unit => { console.log(unit.unitImage.src) });
            }
            spawnBalls();
            
            const endContainer = d.querySelector('.end-container')
            const edcVerdict = d.getElementById('verdict')
            const reTryBtn = d.getElementById('retry-btn')
            var tapToFinish = false
            var end = false
            let chosenBallIdx = NaN
            let finalBallIdx = NaN
            let abortController = new AbortController()
            let count = 0
    
            function drawBalls() {
                units.forEach(unit => {
                    unit.unitImage.onload = () => {
                        unit.draw(ctx)
                    }
                    unit.unitImage.src = unit.source;
                })
            }
            function setBallsToDefault() {
                units.forEach(unit => {
                    unit.unitImage.onload = () => {
                        unit.draw(ctx)
                    }
                    unit.unitImage.src = defaultSource;
                });
            }
            function choiceEvent(e) {
                units.forEach((unit,idx) => {
                    const r = canvas.getBoundingClientRect();
                    const clickX = e.clientX - r.left
                    const clickY = e.clientY - r.top
                    const distance = Math.sqrt((clickX - unit.x) **2 + (clickY - unit.y) **2);

                    if (distance <= unit.r * imageScale) {
                        setBallsToDefault();
                        FillCanvas();
                        
                        unit.unitImage.onload = () => {
                            unit.draw(ctx)
                        }
                        unit.unitImage.src = chosenBallSource;
                    }
                })
                getSelIdx();
            };
            function getSelIdx() {
                units.forEach((unit,idx) => {
                    if (unit.unitImage.src.includes(chosenBallSource)) {
                        chosenBallIdx = idx
                        console.log(chosenBallIdx)
                    }
                });
            };
            function addStopPoint() {
                if (!tapToFinish) canvas.addEventListener(
                    'click', 
                    () => { 
                        console.log(`Game Ended, \nChosen Ball: ${chosenBallIdx}\nLast Ball: ${finalBallIdx}`)
                        canvas.removeEventListener('click', choiceEvent);
                        startBtn.removeEventListener('click', initializeGame);

                        end = true; 
                        tapToFinish=true; 
                        initializeVerdict(chosenBallIdx,finalBallIdx)
                    }, 
                    { signal: abortController.signal }
                );
            };
            function initializeVerdict(initIdx,resIdx) {
                endContainer.style.display = 'flex';
                if (resIdx == initIdx) {
                    edcVerdict.textContent = 'win';
                    win = true
                } else if (time.toFixed(2) > 0 && resIdx !== initIdx) {
                    edcVerdict.textContent = 'loss';
                    win = false
                } else if (time.toFixed(2) == 0) {
                    edcVerdict.textContent = "time's out";
                }
                if (window.innerWidth > window.innerHeight) {
                    setTimeout(() => {
                        // console.log(d.getElementById('wanim-canvas'))
                        d.getElementById('wanim-canvas').style.background = 'none';
                    }, 1);
                }
                winAnim();
            }
            function initializeGame() {
                abortController = new AbortController();
    
                function Timer() { 
                    if (!end) {
                        if (time.toFixed(2) > 0 && !end) {
                            time -= 0.01 
                        } else { 
                            console.log(`Player ran out of time at time: ${time.toFixed(2)}s`)
                            end = true; 
                            tapToFinish = true 
                            initializeVerdict(chosenBallIdx,finalBallIdx);
                        }
                        timer.textContent = `${time.toFixed(2)}s`; setTimeout(Timer,10)
                    }
                };
                function run() {
                    if (!tapToFinish) {
                        units.forEach((unit, idx) => {
                            if (idx !== chosenBallIdx) {
                                ctx.clearRect(unit.x - unit.r * imageScale * 1.2, unit.y - unit.r * imageScale * 1.2, unit.r * 2 * imageScale * 1.2, unit.r * 2 * imageScale * 1.2)
                                unit.unitImage.onload = () => {
                                    unit.draw(ctx)
                                }
                                unit.unitImage.src = defaultSource;
                            } else {
                                ctx.clearRect(unit.x - unit.r * imageScale * 1.2, unit.y - unit.r * imageScale * 1.2, unit.r * 2 * imageScale * 1.2, unit.r * 2 * imageScale * 1.2)
                                units[chosenBallIdx].unitImage.onload = () => {
                                    unit.draw(ctx)
                                }
                                units[chosenBallIdx].unitImage.src = chosenBallSource;
                            }
                        });
                        
                        let randBallIdx,storedRBI;
                        do {
                            randBallIdx = Math.floor(Math.random() * unitnum)
                        } while ( count <= 3 && randBallIdx === chosenBallIdx || randBallIdx === storedRBI );
                        storedRBI = randBallIdx;

                        let rcb = units[randBallIdx];
                        ctx.clearRect(rcb.x - rcb.r * imageScale * 1.2, rcb.y - rcb.r * imageScale * 1.2, rcb.r * 2 * imageScale * 1.2, rcb.r * 2 * imageScale * 1.2)

                        units[randBallIdx].unitImage.src = randBallSource;
                        units[randBallIdx].unitImage.onload = () => {
                            units[randBallIdx].draw(ctx)
                        }
                        
                        finalBallIdx = randBallIdx
                        count += 1
                                                    
                        setTimeout(run, gameSpeed);
                    }
                }
                
                if (chosenBallIdx+1) {
                    startBtn.removeEventListener('click', initializeGame);
                    canvas.removeEventListener('click', choiceEvent);
                    
                    run();
                    Timer();
                    addStopPoint();    
                } else {
                    console.warn('[UNIT SELECTION]: Rule disobedience!');

                    const BG = d.querySelector('.bg')
                    const mainbody = d.createElement('div');
                    const h1 = d.createElement('h1');

                    mainbody.id = 'alert';
                    if (window.innerWidth > window.innerHeight) {
                        mainbody.style.width = 'calc(var(--box-primary-width) * 1.2)';
                    }
                    h1.id = 'alert-h1';
                    h1.textContent = 'select a unit';

                    mainbody.appendChild(h1);
                    d.body.appendChild(mainbody);

                    setTimeout(() => { d.body.removeChild(d.querySelector('#alert')) },1500);
                }
            };
            
            canvas.addEventListener('click', choiceEvent);
            startBtn.addEventListener('click', initializeGame);
            reTryBtn.addEventListener('click', setupGameOrRetry);
    
            function setupGameOrRetry() {
                abortController.abort();

                const wanimCanvas = d.getElementById("wanim-canvas");
                wanimCanvas.remove();
                
                count = 0
                time = Math.max(maxMinTime,timeLimit)
                timer.textContent = `${time.toFixed(2)}s`
    
                end = false
                tapToFinish = false
                chosenBallIdx = NaN
                finalBallIdx = NaN
    
                FillCanvas();
                spawnBalls();
    
                endContainer.style.display = 'none'
    
                canvas.removeEventListener('click', choiceEvent);
                startBtn.removeEventListener('click', initializeGame);
                canvas.addEventListener('click', choiceEvent);
                startBtn.addEventListener('click', initializeGame);
            }
            
            // canvas setup
            function InjectCanvas() {
                const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1))
                const { clientWidth:w, clientHeight:h } = canvas
                canvas.width = w*dpr
                canvas.height = h*dpr
                ctx.setTransform(dpr,0,0,dpr,0,0)
                
                FillCanvas();
                drawBalls();
            }
            function FillCanvas() {
                const W = canvas.clientWidth, H = canvas.clientHeight            
    
                ctx.clearRect(0,0,W,H)
                ctx.fillStyle = 'rgba(0,0,0,0)'
                ctx.fillRect(0,0,W,H)
            }
    
            new ResizeObserver(InjectCanvas).observe(canvas);
            InjectCanvas();
        }
        function winAnim() {
            const endContainer = d.querySelector('.end-container');
            const waCanvas = `<canvas id="wanim-canvas"></canvas>`;
            endContainer.insertAdjacentHTML('afterbegin', waCanvas)

            const wanimCanvas = d.getElementById("wanim-canvas");
            const ctxwa = wanimCanvas.getContext("2d");

            console.log(wanimCanvas.clientWidth,wanimCanvas.clientHeight);
            const dprwa = Math.max(1, Math.min(2, window.devicePixelRatio || 1))
            wanimCanvas.width = wanimCanvas.clientWidth * dprwa
            wanimCanvas.height = wanimCanvas.clientHeight * dprwa
            ctxwa.setTransform(dprwa,0,0,dprwa,0,0)
            ctxwa.clearRect(0, 0, wanimCanvas.width, wanimCanvas.height);
            
            const centerX = wanimCanvas.width / 2;
            const centerY = wanimCanvas.height / 2;
            
            const particles = [];
            const startNum = 10;
            
            const folders = ['colored','plain','selected'];
            const offset = 30;
            
            class Particle {
                constructor(prevXPos) {
                    const offset = 40;
                    const w = wanimCanvas.clientWidth;
                    const h = wanimCanvas.clientHeight;

                    this.x = offset + (Math.random() * (w - offset * 2));
                    this.y = -10;
                    this.d = 30 + (Math.random() * 8 - 3);
                    
                    if (prevXPos) {
                        if (this.x > prevXPos - this.d && this.x < prevXPos + this.d) {
                            while (this.x == prevXPos) {
                                this.x = offset + (Math.random() * (w - offset * 2));
                            }
                        }
                    }
                    
                    this.vy = 0.5 + Math.random() / 4;
                    this.life = 300 + Math.random() * 600;
                    this.angle = 0;
                    this.rotateSpeed = .015;

                    const folders = ['colored','plain','selected'];
                    
                    if (win) {
                        this.source = `assets/${folders[Math.floor(Math.random() * 2)]}/${object}.png`;
                    } else {
                        let idxs = [0,2];
                        this.source = `assets/${folders[idxs[Math.floor(Math.random() * 2)]]}/${object}.png`;
                    }
                    this.image = new Image();
                    this.image.src = this.source;
                }
                update() {
                    this.y += this.vy;
                    this.angle += this.rotateSpeed;

                    if (this.angle >= Math.PI/6) {
                        this.rotateSpeed *= -1;
                    } else if (this.angle <= -Math.PI/6) {
                        this.rotateSpeed *= -1;
                    }
                    this.life--;
                }
                draw() {
                    ctxwa.save();
                    ctxwa.globalAlpha = Math.max(0, Math.min(1, this.life / 150));
                    ctxwa.translate(this.x, this.y);
                    ctxwa.rotate(this.angle);
                    ctxwa.drawImage(this.image, -this.d/2, -this.d/2, this.d, this.d);
                    ctxwa.restore();
                }
            }

            particles.push(new Particle());
            function spawn() {
                setTimeout(() => {
                    particles.push(new Particle(particles.at(-1).x));
                    spawn();
                }, 500);
            };
            spawn();
            
            function animate() {
                ctxwa.clearRect(0, 0, wanimCanvas.width, wanimCanvas.height);
            
                for (let i = particles.length - 1; i >= 0; i--) {
                    let p = particles[i];
                    p.update();
                    p.draw();
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                    }
                }
                requestAnimationFrame(animate);
            }
            animate();
        }
    </script>
</body>
</html>